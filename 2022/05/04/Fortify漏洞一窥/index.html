<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/myAvatar.webp"><link rel="icon" href="/img/myAvatar.webp"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Nova"><meta name="keywords" content="技术 游戏 生活"><meta name="description" content="Path Manipulation解释：当满足以下两个条件时，就会产生 path manipulation 错误：  攻击者可以指定某一文件系统操作中所使用的路径。  攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。   例如，在某一程序中，攻击者可以获得特定的权限，以重写指定的文件或是在其控制的配置环境下运行程序。 例 1： 下面的代码使用来自于 HTTP 请求的"><meta property="og:type" content="article"><meta property="og:title" content="Fortify漏洞一窥"><meta property="og:url" content="https://honosv.github.io/2022/05/04/Fortify%E6%BC%8F%E6%B4%9E%E4%B8%80%E7%AA%A5/index.html"><meta property="og:site_name" content="Nova&#39;s Blog"><meta property="og:description" content="Path Manipulation解释：当满足以下两个条件时，就会产生 path manipulation 错误：  攻击者可以指定某一文件系统操作中所使用的路径。  攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。   例如，在某一程序中，攻击者可以获得特定的权限，以重写指定的文件或是在其控制的配置环境下运行程序。 例 1： 下面的代码使用来自于 HTTP 请求的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://honosv.github.io/img/fortify.webp"><meta property="article:published_time" content="2022-05-04T05:59:53.000Z"><meta property="article:modified_time" content="2023-09-10T01:06:19.571Z"><meta property="article:author" content="Nova"><meta property="article:tag" content="java"><meta property="article:tag" content="安全"><meta property="article:tag" content="漏洞"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://honosv.github.io/img/fortify.webp"><meta name="referrer" content="no-referrer-when-downgrade"><title>Fortify漏洞一窥 - Nova&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"honosv.github.io",root:"/",version:"1.9.1",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Nova's Blog" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Nova</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/mytitle2.webp) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Fortify漏洞一窥"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-05-04 13:59" pubdate>2022年5月4日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 87 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Fortify漏洞一窥</h1><div class="markdown-body"><h2 id="Path-Manipulation"><a href="#Path-Manipulation" class="headerlink" title="Path Manipulation"></a>Path Manipulation</h2><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p>当满足以下两个条件时，就会产生 path manipulation 错误：</p><ol><li><p>攻击者可以指定某一文件系统操作中所使用的路径。</p></li><li><p>攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。</p></li></ol><p>例如，在某一程序中，攻击者可以获得特定的权限，以重写指定的文件或是在其控制的配置环境下运行程序。</p><p><strong>例 1</strong>： 下面的代码使用来自于 HTTP 请求的输入来创建一个文件名。程序员没有考虑到攻击者可能使用像“**../../**tomcat/conf/server.xml”一样的文件名，从而导致应用程序删除它自己的配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String rName = request.getParameter(<span class="hljs-string">&quot;reportName&quot;</span>);<br><br>File rFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;/usr/local/apfr/reports/&quot;</span> + rName);<br><br>...<br><br>rFile.delete()<br></code></pre></td></tr></table></figure><p><strong>例 2</strong>：下面的代码使用来自于配置文件的输入来决定打开哪个文件，并返回给用户。如果程序在一定的权限下运行，<strong>且恶意用户能够篡改配置文件</strong>，那么他们可以通过程序读取系统中以 .txt 扩展名结尾的所有文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">fis = <span class="hljs-keyword">new</span> FileInputStream(cfg.getProperty(<span class="hljs-string">&quot;sub&quot;</span>) + <span class="hljs-string">&quot;.txt&quot;</span>);<br>amt = fis.read(arr);<br>out.println(arr);<br></code></pre></td></tr></table></figure><h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><p><strong>方案一：</strong>创建一份<strong>合法资源名的列表</strong>，并且规定用户只能选择其中的文件名。通过这种方法，用户就不能直接由自己来指定资源的名称了。</p><p>但在某些情况下，这种方法并不可行，因为这样一份合法资源名的列表过于庞大、难以跟踪。因此，程序员通常在这种情况下采用方案二，<strong>黑名单+白名单</strong> 双重过滤路径的办法。</p><p><strong>方案二：</strong>在输入之前，黑名单会有选择地拒绝或避免潜在的危险字符（例如过滤**..**字符）。同时创建一份白名单，允许其中的字符出现在资源名称中，且只接受完全由这些被认可的字符组成的输入。</p><p>Try to normalize the URL before using it</p><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/net/URI.html#normalize()">https://docs.oracle.com/javase/7/docs/api/java/net/URI.html#normalize()</a></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;/foo/../bar/../baz&quot;).normalize();<br></code></pre></td></tr></table></figure><p>or use normalize from <em>org.apache.commons.io.FilenameUtils</em></p><p><a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-io/javadocs/api-1.4/org/apache/commons/io/FilenameUtils.html#normalize(java.lang.String)">https://commons.apache.org/proper/commons-io/javadocs/api-1.4/org/apache/commons/io/FilenameUtils.html#normalize(java.lang.String)</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Stirng path = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FilenameUtils</span>.</span></span>normalize(<span class="hljs-string">&quot;/foo/../bar/../baz&quot;</span>);<br></code></pre></td></tr></table></figure><p>For both the result will be <code>\baz</code></p><h2 id="Race-Condition-Singleton-MemberField"><a href="#Race-Condition-Singleton-MemberField" class="headerlink" title="Race Condition: Singleton MemberField"></a>Race Condition: Singleton MemberField</h2><p>Servlet 成员字段可能允许一个用户查看其他用户的数据。</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>许多 Servlet 开发人员都不了解 Servlet 为单例模式。 Servlet 只有一个实例，并通过使用和重复使用该单个实例来处理需要由不同线程同时处理的多个请求。 这种误解的共同后果是，开发者使用 Servlet 成员字段的这种方式会导致某个用户可能在无意中看到其他用户的数据。 换言之，即把用户数据存储在 Servlet 成员字段中会引发数据访问的 race condition。<br>例 1： 以下 Servlet 把请求参数值存储在成员字段中，然后将参数值返回给响应输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuestBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    String name;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse res)</span> </span>&#123;<br>        name = req.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<br>        ...<br>        out.println(name + <span class="hljs-string">&quot;, thanks for visiting!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当该代码在单一用户环境中正常运行时，如果有两个用户几乎同时访问 Servlet，可能会导致这两个请求以如下方式处理线程的插入：<br>线程 1： assign “Dick” to name<br>线程 2： assign “Jane” to name<br>线程 1： print “Jane, thanks for visiting!”<br>线程 2： print “Jane, thanks for visiting!”<br>因此会向第一个用户显示第二个用户的用户名。</p><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>不要为任何参数（常量除外）使用 Servlet 成员字段。 （例如，确保所有成员字段都是 static final）。当开发者需要把代码内某一部分中的数据传输到另一部分时，他们经常使用 Servlet 成员字段存储用户数据。 如果您也是这么做的，可以考虑声明一个单独的类，并仅使用 Servlet “封装”这个新类。<br>例 2： 上述例子中的 bug 可以利用以下方式进行修正：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuestBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse res)</span> </span>&#123;<br>        GBRequestHandler handler = <span class="hljs-keyword">new</span> GBRequestHandler();<br>        handler.handle(req, res);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GBRequestHandler</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res)</span> </span>&#123;<br>        name = req.getParameter(<span class="hljs-string">&quot;name&quot;</span>);<br>        ...<br>        out.println(name + <span class="hljs-string">&quot;, thanks for visiting!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外， Servlet 也可以利用同步代码块来访问 servlet 实例变量。但是，使用同步代码块可能会导致严重的性能问题。</p><h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>执行不可信赖资源中的命令，或在不可信赖的环境中执行命令，都会导致程序以攻击者的名义执行恶意命令。</p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>Command Injection 漏洞主要表现为以下两种形式：</p><p>－ 攻击者能够篡改程序执行的命令：攻击者直接控制了所执行的命令。</p><p>－ 攻击者能够篡改命令的执行环境：攻击者间接地控制了所执行的命令。</p><p>在这种情况下，我们着重关注第一种情况，即攻击者有可能控制所执行命令。这种类型的 Command Injection 漏洞会在以下情况下出现：</p><p>\1. 数据从不可信赖的数据源进入应用程序。</p><p>\2. 数据被用作代表应用程序所执行命令的字符串，或字符串的一部分。</p><p>\3. 通过命令的执行，应用程序会授予攻击者一种原本不该拥有的特权或能力。</p><p><strong>例 1：</strong>下面这段来自系统实用程序的代码根据系统属性 <code>APPHOME</code> 来决定其安装目录，然后根据指定目录的相对路径执行一个初始化脚本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>String home = System.getProperty(<span class="hljs-string">&quot;APPHOME&quot;</span>);<br>String cmd = home + INITCMD;<br>java.lang.Runtime.getRuntime().exec(cmd);<br>...<br></code></pre></td></tr></table></figure><p><code>Example 1</code> 中的代码可以使攻击者通过修改系统属性 <code>APPHOME</code> 以指向包含恶意版本 <code>INITCMD</code> 的其他路径来提高自己在应用程序中的权限，继而随心所欲地执行命令。由于程序不会验证从环境中读取的值，因此如果攻击者能够控制系统属性 <code>APPHOME</code> 的值，他们就能欺骗应用程序去运行恶意代码，从而取得系统控制权。</p><p><strong>例 2：</strong>下面的代码来自一个管理 Web 应用程序，旨在使用户能够使用一个围绕 <code>rman</code> 实用程序的批处理文件封装器来启动 Oracle 数据库备份，然后运行一个 <code>cleanup.bat</code> 脚本来删除一些临时文件。脚本 <code>rmanDB.bat</code> 接受单个命令行参数，该参数指定了要执行的备份类型。由于访问数据库受限，所以应用程序执行备份需要具有较高权限的用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>String btype = request.getParameter(<span class="hljs-string">&quot;backuptype&quot;</span>);<br>String cmd = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;cmd.exe /K</span><br><span class="hljs-string">\&quot;c:\\util\\rmanDB.bat &quot;</span>+btype+<span class="hljs-string">&quot;&amp;&amp;c:\\util\\cleanup.bat\&quot;&quot;</span>)<br>System.Runtime.getRuntime().exec(cmd);<br>...<br></code></pre></td></tr></table></figure><p>这里的问题是：程序没有对读取自用户的 <code>backuptype</code>参数进行任何验证。通常情况下 <code>Runtime.exec()</code> 函数不会执行多条命令，但在这种情况下，程序会首先运行 <code>cmd.exe</code> shell，从而可以通过调用一次 <code>Runtime.exec()</code> 来执行多条命令。在调用该 shell 之后，它即会允许执行用两个与号分隔的多条命令。如果攻击者传递了一个形式为 <code>&quot;&amp;&amp; del c:\\dbms\\*.*&quot;</code> 的字符串，那么应用程序将随程序指定的其他命令一起执行此命令。由于该应用程序的特性，运行该应用程序需要具备与数据库进行交互所需的权限，这就意味着攻击者注入的任何命令都将通过这些权限得以运行。</p><p><strong>示例 3：</strong>下面的代码来自一个 Web 应用程序，用户可通过该应用程序提供的界面在系统上更新他们的密码。在某些网络环境中更新密码时，其中的一个步骤就是在 <code>/var/yp</code> 目录中运行 <code>make</code> 命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>System.Runtime.getRuntime().exec(<span class="hljs-string">&quot;make&quot;</span>);<br>...<br></code></pre></td></tr></table></figure><p>这里的问题在于程序没有在它的构造中指定一个绝对路径，并且没能在执行 <code>Runtime.exec()</code> 调用前清除它的环境变量。如果攻击者能够修改 <code>$PATH</code> 变量，把它指向名为 <code>make</code> 恶意二进制代码，程序就会在其指定的环境下执行，然后加载该恶意二进制代码，而非原本期望的代码。由于应用程序自身的特性，运行该应用程序需要具备执行系统操作所需的权限，这意味着攻击者会利用这些权限执行自己的 <code>make</code>，从而可能导致攻击者完全控制系统。</p><p>有些人认为在移动世界中，典型的漏洞（如 Command Injection）是无意义的 – 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。</p><p><strong>例 4：</strong>以下代码可从 Android Intent 中读取要执行的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>        String[] cmds = <span class="hljs-keyword">this</span>.getIntent().getStringArrayExtra(<span class="hljs-string">&quot;commands&quot;</span>);<br>		Process p = Runtime.getRuntime().exec(<span class="hljs-string">&quot;su&quot;</span>);<br>        DataOutputStream os = <span class="hljs-keyword">new</span> DataOutputStream(p.getOutputStream());<br>        <span class="hljs-keyword">for</span> (String cmd : cmds) &#123;<br>        	os.writeBytes(cmd+<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        os.writeBytes(<span class="hljs-string">&quot;exit\n&quot;</span>);<br>        os.flush();<br>...<br></code></pre></td></tr></table></figure><p>在经过 root 的设备上，恶意应用程序会强迫受攻击应用程序使用超级用户权限执行任意命令。</p><h4 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h4><p>应当禁止用户直接控制由程序执行的命令。 在用户的输入会影响命令执行的情况下，应将用户输入限制为从预定的安全命令集合中进行选择。 如果输入中出现了恶意的内容，传递到命令执行函数的值将默认从安全命令集合中选择，或者程序将拒绝执行任何命令。</p><p>在需要将用户的输入用作程序命令中的参数时，由于合法的参数集合实在很大，或是难以跟踪，使得这个方法通常都不切实际。 开发者通常的做法是使用黑名单。 在输入之前，黑名单会有选择地拒绝或避免潜在的危险字符。</p><p>但是，任何一个定义不安全内容的列表都很可能是不完整的，并且会严重地依赖于执行命令的环境。 较好的方法是创建一份白名单，允许其中的字符出现在输入中，并且只接受完全由这些经认可的字符组成的输入。</p><p>攻击者可以通过修改程序运行命令的环境来间接控制这些命令的执行。 我们不应当完全信赖环境，还需采取预防措施，防止攻击者利用某些控制环境的手段进行攻击。 无论何时，只要有可能，都应由应用程序来控制命令，并使用绝对路径执行命令。 如果编译时尚不了解路径（如在跨平台应用程序中），应该在执行过程中利用可信赖的值构建一个绝对路径。 应对照一系列定义有效值的常量，仔细地检查从配置文件或者环境中读取的命令值和路径。</p><p>有时还可以执行其他检验，以检查这些来源是否已被恶意篡改。 例如，如果一个配置文件为可写，程序可能会拒绝运行。 如果能够预先得知有关要执行的二进制代码的信息，程序就会进行检测，以检验这个二进制代码的合法性。 如果一个二进制代码始终属于某个特定的用户，或者被指定了一组特定的访问权限，这些属性就会在执行二进制代码前通过程序进行检验。 尽管可能无法完全阻止强大的攻击者为了控制程序执行的命令而对系统进行的攻击，但只要程序执行外部命令，就务必使用最小授权原则： 不给予超过执行该命令所必需的权限。</p><h2 id="Cross-Site-Scripting-Content-Sniffing"><a href="#Cross-Site-Scripting-Content-Sniffing" class="headerlink" title="Cross-Site Scripting: Content Sniffing"></a>Cross-Site Scripting: Content Sniffing</h2><p>向 Web 浏览器发送未经验证的数据可能导致某些浏览器执行恶意代码。</p><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><p>Cross-Site Scripting (XSS) 漏洞会在以下情况下出现：</p><p>1.数据通过一个不可信赖的数据源进入 Web 应用程序。对于 Reflected XSS，不可信赖的数据源通常为 Web 请求，而对于 Persisted（也称为 Stored）XSS，该数据源通常为数据库或其他后端数据存储。</p><p>2.未经验证但包含在动态内容中的数据将传送给 Web 用户。</p><p>传送到 Web 浏览器的恶意内容通常采用 JavaScript 片段的形式，但也可能会包含一些 HTML、Flash 或者其他任意一种可以被浏览器执行的代码。基于 XSS 的攻击手段花样百出，几乎是无穷无尽的，但通常它们都会包含传输给攻击者的私有数据（如 Cookie 或者其他会话信息）。在攻击者的控制下，指引受害者进入恶意的网络内容；或者利用易受攻击的站点，对用户的机器进行其他恶意操作。</p><p>为了让浏览器将响应呈现为 HTML 或者可执行脚本的其他文档，必须指定<code>text/html</code>MIME 类型。因此，仅当响应使用此 MIME 类型或者使用的任何其他类型同样强制浏览器将响应呈现为 HTML 或可执行 SVG 图像 (<code>image/svg+xml</code>) 和 XML 文档 (<code>application/xml</code>) 等脚本的其他文档时，才有可能使用 XSS。</p><p>大多数现代浏览器不会呈现 HTML，也不会在为响应提供<code>application/json</code>等 MIME 类型时执行脚本。但是，Internet Explorer 等某些浏览器可执行称为<code>Content Sniffing</code>的内容。Content Sniffing 涉及到忽略提供的 MIME 类型并尝试根据响应的内容推断正确的 MIME 类型。<br>但是，值得注意的是，MIME 类型的<code>text/html</code>是可能导致 XSS 漏洞的唯一 MIME 类型。可执行 SVG 图像 (<code>image/svg+xml</code>) 和 XML 文档 (<code>application/xml</code>) 等脚本的其他文档可能导致 XSS 漏洞，无论浏览器是否执行 Content Sniffing 都是如此。</p><p>因此，<code>&lt;html&gt;&lt;body&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code>等响应可能呈现为 HTML，即使其 <code>content-type</code> 标头设置为 <code>application/json</code> 也是如此。</p><p><strong>示例 1：</strong>以下 JAX-RS 方法反映 <code>application/json</code>响应中的用户数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Path(&quot;/myResource&quot;)</span><br><span class="hljs-meta">@Produces(&quot;application/json&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeResource</span> </span>&#123;<br>	<span class="hljs-meta">@GET</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doGetAsJson</span><span class="hljs-params">(<span class="hljs-meta">@QueryParam(&quot;param&quot;)</span> String param)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#x27;name&#x27;: &#x27;&quot;</span> + param + <span class="hljs-string">&quot;&#x27;&#125;&quot;</span>;	<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果攻击者所发送请求的 <code>name</code>参数设置为 <code>&lt;html&gt;&lt;body&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code>，则服务器将生成以下响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>88<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Closed<br><br><span class="xml">&#123;&#x27;name&#x27;: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>尽管响应明确声明应该将其视为 JSON 文档，但旧浏览器仍可能尝试将其呈现为 HTML 文档，使其容易受到 Cross-Site Scripting 攻击。</p><h4 id="建议-2"><a href="#建议-2" class="headerlink" title="建议"></a>建议</h4><p>所以根据XSS漏洞产生的原因，对于XSS脚本攻击的漏洞修复，主要解决方案是：</p><p>a、对输入源进行校验和过滤；</p><p>b、对输出源进行校验和过滤；</p><p><strong>例：</strong></p><p>提供公共方法，结合实际业务需求，对输入源和输出源调用该方法进行特殊字符的过滤，主要是浏览器脚本可能包含的一些特殊字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">filterInput</span><span class="hljs-params">(String input)</span> </span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;&lt;&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;&gt;&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;(&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;)&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;?&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;;&quot;</span>);<br>    String encode = Normalizer.normalize(input, Normalizer.Form.NFKC);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;<br>        encode = encode.replace(s, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> encode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Often-Misused-File-Upload"><a href="#Often-Misused-File-Upload" class="headerlink" title="Often Misused: File Upload"></a>Often Misused: File Upload</h2><p>允许用户上传文件可能导致攻击者注入危险内容或恶意代码以便在服务器上运行。</p><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><p>无论编写程序所用的语言是什么，最具破坏性的攻击通常都会涉及执行远程代码，攻击者借此可在程序上下文中成功执行恶意代码。如果允许攻击者向某个可通过 Web 访问的目录上传文件，并能够将这些文件传递给代码解释器（如 JSP/ASPX/PHP），他们就能促使这些文件中包含的恶意代码在服务器上执行。</p><p><strong>示例：</strong>以下 Spring MVC 控制器类包含可用于处理上传文件的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFormController</span> </span>&#123;<br>    ...<br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">uploadFile</span> <span class="hljs-params">(org.springframework.web.multipart.MultipartFile file)</span> </span>&#123;<br>       ...<br>    &#125;    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>即使程序将上传的文件存储在一个无法通过 Web 访问的目录中，攻击者仍然有可能通过向服务器环境引入恶意内容来发动其他攻击。如果程序容易出现 path manipulation、command injection 或危险的 file inclusion 漏洞，那么攻击者就可能上传带恶意内容的文件，并利用另一种漏洞促使程序读取或执行该文件。</p><h4 id="建议-3"><a href="#建议-3" class="headerlink" title="建议"></a>建议</h4><p>对上传文件做好校验：</p><ol><li>文件类型，做好类型白名单，通过文件头来判断类型</li><li>文件大小，不同业务做不同限制</li><li>压缩文件，要提防zip炸弹</li></ol><h2 id="Resource-Injection"><a href="#Resource-Injection" class="headerlink" title="Resource Injection"></a>Resource Injection</h2><p>使用用户输入控制资源标识符，借此攻击者可以访问或修改其他受保护的系统资源。</p><h4 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h4><p>当满足以下两个条件时，就会发生 resource injection：</p><p>\1. 攻击者可以指定已使用的标识符来访问系统资源。</p><p>例如，攻击者可能可以指定用来连接到网络资源的端口号。</p><p>\2. 攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。</p><p>例如，程序可能会允许攻击者把敏感信息传输到第三方服务器。</p><p>资源注入攻击与<a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Path_Manipulation">路径操纵</a>不同，因为资源注入侧重于访问本地文件系统以外的资源，而 <a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Path_Manipulation">路径操纵</a>侧重于访问本地文件系统。</p><p><strong>示例 1：</strong>下面的代码使用读取自 HTTP 请求的端口号来建立一个套接字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String remotePort = request.getParameter(<span class="hljs-string">&quot;remotePort&quot;</span>);<br>...<br>ServerSocket srvr = <span class="hljs-keyword">new</span> ServerSocket(remotePort);<br>Socket skt = srvr.accept();<br>...<br></code></pre></td></tr></table></figure><p>有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 resource injection）是无意义的 – 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。</p><p><strong>示例 2：</strong>下面的代码使用读取自 Android Intent 的 URL 在 <code>WebView</code> 中加载页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>	WebView webview = <span class="hljs-keyword">new</span> WebView(<span class="hljs-keyword">this</span>);<br>	setContentView(webview);<br>    String url = <span class="hljs-keyword">this</span>.getIntent().getExtras().getString(<span class="hljs-string">&quot;url&quot;</span>);<br>	webview.loadUrl(url);<br>...<br></code></pre></td></tr></table></figure><p>这种受用户输入影响的资源表明其中的内容可能存在危险。例如，包含如句点、斜杠和反斜杠等特殊字符的数据在与 file system 相作用的方法中使用时，具有很大风险。类似的，对于创建远程结点的函数来说，包含 URL 和 URI 的数据也具有很大风险。</p><h2 id="Formula-Injection"><a href="#Formula-Injection" class="headerlink" title="Formula Injection"></a>Formula Injection</h2><p>攻击者可能会控制写入到电子表格的数据，借此让用户打开某些电子表格处理器上的文件。</p><h4 id="解释-5"><a href="#解释-5" class="headerlink" title="解释"></a>解释</h4><p>常用电子表格处理器（如 Apache OpenOffice Calc 和 Microsoft Office Excel）支持的公式运算非常强大，这可能会使攻击者控制电子表格而在底层系统上运行任意命令或在电子表格上泄漏敏感信息。</p><p>例如，攻击者可能会将以下有效负载作为 CSV 字段的一部分注入：<code>=cmd|&#39;/C calc.exe&#39;!Z0</code>。如果打开电子表格的用户信任文档来源，他们可能就会接受电子表格处理器提供的所有安全提示信息，并使此有效负载（此处为打开 Windows 计算器）在其系统上运行。</p><p><strong>示例：</strong>以下示例展示了使用未经检查的用户控制数据生成 CSV 响应的 Spring 控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/api/service.csv&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">service</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;name&quot;)</span> String name)</span> </span>&#123;<br><br>    HttpHeaders responseHeaders = <span class="hljs-keyword">new</span> HttpHeaders();<br>    responseHeaders.add(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/csv; charset=utf-8&quot;</span>);<br>    responseHeaders.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=file.csv&quot;</span>);<br><br>    String data = generateCSVFor(name);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(data, responseHeaders, HttpStatus.OK);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>fortify源代码扫描问题分析汇总：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39997829/article/details/118970901">https://blog.csdn.net/weixin_39997829/article/details/118970901</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AE%89%E5%85%A8/" class="category-chain-item">安全</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/java/">#java</a> <a href="/tags/%E5%AE%89%E5%85%A8/">#安全</a> <a href="/tags/%E6%BC%8F%E6%B4%9E/">#漏洞</a></div></div><div class="license-box my-3"><div class="license-title"><div>Fortify漏洞一窥</div><div>https://honosv.github.io/2022/05/04/Fortify漏洞一窥/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Nova</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年5月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/05/04/0%E5%89%8D%E7%AB%AF%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%A2%AB%E4%BB%BB%E5%A4%A9%E5%A0%82%E9%80%BC%E7%9D%80%E5%86%99%E4%BA%86%E4%B8%AA%E7%BD%91%E9%A1%B5/" title="0前端经验，被任天堂逼着写了个网页"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">0前端经验，被任天堂逼着写了个网页</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/03/06/mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" title="mybatis逆向工程"><span class="hidden-mobile">mybatis逆向工程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"HonoSV/HonoSV.github.io","repo-id":"R_kgDOGi5URw","category":"Announcements","category-id":"DIC_kwDOGi5UR84CZmih","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-t}),0<o.find(".toc-list-item").length&&o.css("visibility","visible"))})</script><script>!function(){var i,t=CONFIG.code_language.enable&&CONFIG.code_language.default,c=CONFIG.copy_btn;(t||c)&&(i="",i+='<div class="code-widget">',i+="LANG",i+="</div>",jQuery(".markdown-body pre").each(function(){var e,a,n=jQuery(this);0<n.find("code.mermaid").length||0<n.find("span.line").length||(e="",t&&(e=CONFIG.code_language.default,0<n[0].children.length&&2<=n[0].children[0].classList.length&&n.children().hasClass("hljs")?e=n[0].children[0].classList[1]:n[0].getAttribute("data-language")?e=n[0].getAttribute("data-language"):n.parent().hasClass("sourceCode")&&0<n[0].children.length&&2<=n[0].children[0].classList.length?(e=n[0].children[0].classList[1],n.parent().addClass("code-wrapper")):n.parent().hasClass("markdown-body")&&0===n[0].classList.length&&n.wrap('<div class="code-wrapper"></div>'),e=e.toUpperCase().replace("NONE",CONFIG.code_language.default)),n.append(i.replace("LANG",e).replace('code-widget">',(a=n[0],(0<=Fluid.utils.getBackgroundLightness(a)?"code-widget-light":"code-widget-dark")+(c?' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>':' code-widget">')))),c&&Fluid.utils.createScript("https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js",function(){new window.ClipboardJS(".copy-btn",{target:function(e){for(var a=e.parentNode.childNodes,n=0;n<a.length;n++)if("CODE"===a[n].tagName)return a[n]}}).on("success",function(e){e.clearSelection(),e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-copy","icon-success"),setTimeout(function(){e.trigger.innerHTML=e.trigger.innerHTML.replace("icon-success","icon-copy")},2e3)})}))}))}()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>